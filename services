#!/usr/bin/env bash
#
# The main entry point script to utilise the various commands
#
# Please see https://github.com/qcr/services for full details on how
# things work


#################
### VARIABLES ###
#################

# Valid commands should be the file name of valid scripts to call
# held within the scripts folder
VALID_CMDS=("current" "list" "new" "update")

INSTALL_DIR="/var/tmp/tools/"
REPO_DIR="${INSTALL_DIR}/services"
REPO_URL="https://github.com/qcr/services"

# Screen Colour Helpers
# Can't import common script as this script must be standalone
# due to how the qcr tool operates
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
NORMAL=$(tput sgr0)

ERROR="${RED}[ERROR]${NORMAL}"
WARNING="${YELLOW}[WARNING]${NORMAL}"
INFO="${GREEN}[INFO]${NORMAL}"


#################
### FUNCTIONS ###
#################

function print_usage(){
    printf "\nRuns the QCR Services tool.
    
Usage:
    ./services -L <command> <arguments>

Input Arguments:
    <command>       the QCR service command to run.
    <arguments>     the arguments for the QCR service command.
    -L              use local version of services tool

"
}


############
### MAIN ###
############

# Parse arguments
USE_LOCAL_VERSION=false
while getopts Lh OPT; do
    case "${OPT}" in
        L) USE_LOCAL_VERSION=true ;;
        h) print_usage; exit ;;
        ?) print_usage; exit ;;
    esac
done

# echo "Use Local Version: ${USE_LOCAL_VERSION}"

# Valid number of arguments
if [ $# -eq 0 ] || [ $# -eq 1 ] && [ ${USE_LOCAL_VERSION} == true ]; then
    print_usage
    exit
fi

# Turn arguments into array, and remove first -L if present
ARGS=( "$@" )
if [ ${USE_LOCAL_VERSION} == true ]; then
    ARGS=( "${ARGS[@]:1}" )
fi

# Check command argument is valid
# echo "Args: ${ARGS[@]}"
CMD=${ARGS[0]}
# echo "Command: ${CMD}"
# exit
if [[ ! " ${VALID_CMDS[*]} " =~ " ${CMD} "  ]]; then
    printf "${ERROR} - the command ${YELLOW}${CMD}${NORMAL} does not exist.\n"
    print_usage
fi


# Run script with arguments
CMD=${ARGS[@]}
# echo "CMD: ${CMD}"
if [ ${USE_LOCAL_VERSION} == true ]; then
    # Use local version
    /bin/bash scripts/${CMD}
else
    # Install/cache git version, look to see if there are updates

    # Bail if git isn't found
    command -v git >& /dev/null || {
        printf "${ERROR} - the 'git' command was not found, please install\n"
        exit 1
    }

    # Create repo if doesn't exist
    if [ ! -d "$REPO_DIR" ]; then
        printf "${INFO} - No cached version of the services tool found. Installing to '$REPO_DIR'...\n"
        if ! git clone "$REPO_URL" "$REPO_DIR"; then
            printf "${ERROR} - Install failed, please ensure machine has Internet access.\n"
            exit 1
        fi
    fi
    printf "\n"

    # Check whether installed version is the latest (flagging if there are updates
    # available, or update check failed)
    latest="$(git -C "${REPO_DIR}" ls-remote 2>/dev/null | grep HEAD | cut -f 1 || true)"
    installed="$(git -C "$REPO_DIR" rev-parse HEAD)"
    if [ -z "$latest" ]; then
        printf "${WARNING} - check for latest tools failed; using cached version in '$REPO_DIR'.\n"
    elif [ "$latest" != "$installed" ]; then
        printf "${WARNING}${YELLOW} - %s\n\t    %s\t%s\n\n${NORMAL}" \
        "Old version (${installed:0:8}) found in '$REPO_DIR'." \
        "Update to latest (${latest:0:8}) using:" \
        "qcr update services"
    fi

    # Run tool
    /bin/bash ${REPO_DIR}/scripts/${CMD}
fi

