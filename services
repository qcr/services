#!/usr/bin/env bash
#
# The main entry point script to utilise the various commands
#
# Please see https://github.com/qcr/services for full details on how
# things work


#################
### VARIABLES ###
#################


# Directory for this script
SCRIPT_DIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# Valid commands should be the file name of valid scripts to call
# held within the scripts folder
VALID_CMDS=("current-user" "list" "new" "update")

# Screen Colour Helpers
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
NORMAL=$(tput sgr0)

# Helper variables
ERROR="${RED}[ERROR]${NORMAL}"
WARNING="${YELLOW}[WARNING]${NORMAL}"
INFO="${GREEN}[INFO]${NORMAL}"


#################
### FUNCTIONS ###
#################

function print_usage(){
    printf "\nRuns the QCR Services tool.
    
Usage:
    services <command> <arguments>

Arguments:
    <command>       the QCR service command to run.
    <arguments>     the arguments for the QCR service command.

"
}


############
### MAIN ###
############

# Parse arguments
USE_LOCAL_VERSION=false
while getopts h OPT; do
    case "${OPT}" in
        h|help) print_usage; exit ;;
        ?) print_usage; exit ;;
    esac
done

# Valid number of arguments
if [ $# -eq 0 ]; then # || ([ $# -eq 1 ] && [ ${USE_LOCAL_VERSION} == true ]); then
    print_usage
    exit
fi


# Check command argument is valid
ARGS=( "$@" )
CMD=${ARGS[0]}
if [[ ! " ${VALID_CMDS[*]} " =~ " ${CMD} "  ]]; then
    printf "${ERROR} the command ${YELLOW}${CMD}${NORMAL} does not exist.\n"
    print_usage
    exit
fi

# Get sub-script and arguments
CMD=${ARGS[0]}
ARGS_LIST=${ARGS[@]:1}

# Print to terminal what is being called
if [ ${#ARGS_LIST[@]} == 1 ] && [ "${ARGS_LIST[0]}" == "" ]; then
    printf "${INFO} calling '${YELLOW}services ${CMD}${NORMAL}' with no arguments\n"
else
    printf "${INFO} calling '${YELLOW}services ${CMD}${NORMAL}' with arguments '${YELLOW}${ARGS[@]:1}${NORMAL}'\n"
fi

# Run tool
/bin/bash ${SCRIPT_DIR}/scripts/${CMD}${ARGS_LIST[@]}
