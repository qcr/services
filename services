#!/usr/bin/env bash
#
# The main entry point script to utilise the various commands
#
# Please see https://github.com/qcr/services for full details on how
# things work


#################
### VARIABLES ###
#################


# Directory for this script
SCRIPT_DIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# Valid commands should be the file name of valid scripts to call
# held within the scripts folder
VALID_CMDS=("current-user" "list" "new" "update")

# Screen Colour Helpers
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
NORMAL=$(tput sgr0)

# Helper variables
ERROR="${RED}[ERROR]${NORMAL}"
WARNING="${YELLOW}[WARNING]${NORMAL}"
INFO="${GREEN}[INFO]${NORMAL}"


#################
### FUNCTIONS ###
#################

function print_usage(){
    printf "\nRuns the QCR Services tool.
    
Usage:
    ./services <command> <arguments>

Input Arguments:
    <command>       the QCR service command to run.
    <arguments>     the arguments for the QCR service command.

"
}


############
### MAIN ###
############

# Parse arguments
USE_LOCAL_VERSION=false
while getopts h OPT; do
    case "${OPT}" in
        h|help) print_usage; exit ;;
        ?) print_usage; exit ;;
    esac
done

# Valid number of arguments
if [ $# -eq 0 ]; then # || ([ $# -eq 1 ] && [ ${USE_LOCAL_VERSION} == true ]); then
    print_usage
    exit
fi

# # Turn arguments into array, and remove first -L if argument was present
# #   > getopts only passes up to first non-optional command
# #   > for example, if call 'services -L list -F' getopts would only
# #   > parse the -L and ignore everything after list
# ARGS=( "$@" )
# if [ ${USE_LOCAL_VERSION} == true ]; then
#     ARGS=( "${ARGS[@]:1}" )
# fi

# # Check to see if -L flag present in remaining arguments
# # TODO - probably a better way of searching for this
# for i in ${ARGS[@]}; do
#     # Check if contains L flag
#     if [[ "$i" =~ "L" ]] && [[ $i =~ "-" ]]; then
#         printf "${ERROR} if attempting to run the local version, the -L flag must come directly after 'services'.\n"
#         print_usage
#         exit
#     fi
# done

# Check command argument is valid
ARGS=( "$@" )
CMD=${ARGS[0]}
if [[ ! " ${VALID_CMDS[*]} " =~ " ${CMD} "  ]]; then
    printf "${ERROR} the command ${YELLOW}${CMD}${NORMAL} does not exist.\n"
    print_usage
    exit
fi

# Get sub-script and arguments
CMD=${ARGS[0]}
ARGS_LIST=${ARGS[@]:1}

# Print to terminal what is being called
if [ ${#ARGS_LIST[@]} == 1 ] && [ "${ARGS_LIST[0]}" == "" ]; then
    printf "${INFO} calling '${YELLOW}services ${CMD}${NORMAL}' with no arguments\n"
else
    printf "${INFO} calling '${YELLOW}services ${CMD}${NORMAL}' with arguments '${YELLOW}${ARGS[@]:1}${NORMAL}'\n"
fi

# Run tool
echo "${SCRIPT_DIR}/scripts/${CMD} ${ARGS_LIST[@]}"
# /bin/bash ${SCRIPT_DIR}/scripts/${CMD}${ARGS_LIST[@]}
